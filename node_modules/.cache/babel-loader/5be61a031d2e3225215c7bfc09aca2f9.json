{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nexport const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nexport const buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\n\nexport function checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport const createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  const dataRowIdToIdLookup = {};\n\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToIdLookup,\n    dataRowIdToModelLookup\n  };\n};\nexport const getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport const getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths\n}) => {\n  const cache = apiRef.current.caches.rows; // 1. Apply the \"rowTreeCreation\" family processing.\n\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  }); // 2. Apply the \"hydrateRows\" pipe-processing.\n\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  }); // 3. Reset the cache updates\n\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp\n  });\n};\nexport const isAutoGeneratedRow = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexport const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n\n  if (node.type !== 'group') {\n    return [];\n  }\n\n  const validDescendants = [];\n\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n\n    validDescendants.push(...getTreeNodeDescendants(tree, child, skipAutoGeneratedRows));\n  }\n\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n\n  return validDescendants;\n};\nexport const updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates\n}) => {\n  var _previousCache$update, _previousCache$update2, _previousCache$update3;\n\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI: Unable to prepare a partial update if a full update is not applied yet');\n  } // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n\n\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...((_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : [])],\n      modify: [...((_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : [])],\n      remove: [...((_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : [])]\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n\n  const dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n\n  const dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  }; // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id]; // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      } // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n\n\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      } // Remove the data row from the lookups and add it to the \"delete\" update.\n\n\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n\n    const oldRow = dataRowIdToModelLookup[id]; // Action === \"modify\"\n\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      } // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      } // Update the data row lookups.\n\n\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    } // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n\n\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    } // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    } // Update the data row lookups.\n\n\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n\n  return {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  var _pinnedRows$top, _pinnedRows$bottom;\n\n  const pinnedRows = gridPinnedRowsSelector(apiRef);\n  const topPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  const bottomPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef, rowHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  return 2 * Math.floor(rowHeight * densityFactor);\n}","map":{"version":3,"sources":["C:/Users/thang/Downloads/Code structure/node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsUtils.js"],"names":["_extends","gridPinnedRowsSelector","gridDensityFactorSelector","GRID_ROOT_GROUP_ID","buildRootGroup","type","id","depth","groupingField","groupingKey","isAutoGenerated","children","childrenFromPath","childrenExpanded","parent","checkGridRowIdIsValid","row","detailErrorMessage","Error","JSON","stringify","join","getRowIdFromRowModel","rowModel","getRowId","createRowsInternalCache","rows","loading","rowCount","updates","dataRowIdToModelLookup","dataRowIdToIdLookup","i","length","model","push","rowsBeforePartialUpdates","loadingPropBeforePartialUpdates","rowCountPropBeforePartialUpdates","getTopLevelRowCount","tree","rowCountProp","rootGroupNode","Math","max","footerId","getRowsStateFromCache","apiRef","loadingProp","previousTree","previousTreeDepths","cache","current","caches","unProcessedTree","treeDepths","unProcessedTreeDepths","dataRowIds","unProcessedDataRowIds","groupingName","applyStrategyProcessor","groupingParamsWithHydrateRows","unstable_applyPipeProcessors","actions","insert","modify","remove","idToActionLookup","totalRowCount","totalTopLevelRowCount","isAutoGeneratedRow","rowNode","getTreeNodeDescendants","parentId","skipAutoGeneratedRows","node","validDescendants","child","updateCacheWithNewRows","previousCache","_previousCache$update","_previousCache$update2","_previousCache$update3","uniqueUpdates","Map","forEach","update","has","set","get","partialUpdates","alreadyAppliedActionsToRemove","partialRow","actionAlreadyAppliedToRow","_action","oldRow","actionTypeWithActionsToRemove","Object","keys","actionType","idsToRemove","filter","calculatePinnedRowsHeight","_pinnedRows$top","_pinnedRows$bottom","pinnedRows","topPinnedRowsHeight","top","reduce","acc","value","unstable_getRowHeight","bottomPinnedRowsHeight","bottom","getMinimalContentHeight","rowHeight","densityFactor","floor"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nexport const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nexport const buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexport function checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport const createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  const dataRowIdToIdLookup = {};\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToIdLookup,\n    dataRowIdToModelLookup\n  };\n};\nexport const getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport const getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths\n}) => {\n  const cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp\n  });\n};\nexport const isAutoGeneratedRow = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexport const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  const validDescendants = [];\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n    validDescendants.push(...getTreeNodeDescendants(tree, child, skipAutoGeneratedRows));\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexport const updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates\n}) => {\n  var _previousCache$update, _previousCache$update2, _previousCache$update3;\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI: Unable to prepare a partial update if a full update is not applied yet');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...((_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : [])],\n      modify: [...((_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : [])],\n      remove: [...((_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : [])]\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n  const dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n    const oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n  return {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  var _pinnedRows$top, _pinnedRows$bottom;\n  const pinnedRows = gridPinnedRowsSelector(apiRef);\n  const topPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  const bottomPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef, rowHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  return 2 * Math.floor(rowHeight * densityFactor);\n}"]},"metadata":{},"sourceType":"module"}