{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutoGeneratedRow, GRID_ROOT_GROUP_ID, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n\n    if (model) {\n      return model;\n    }\n\n    const node = apiRef.current.getRowNode(id);\n\n    if (node && isAutoGeneratedRow(node)) {\n      // TODO rows v6: Is it the best approach ?\n      return {};\n    }\n\n    return null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(({\n    cache,\n    throttle\n  }) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.caches.rows = cache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    const cache = updateCacheWithNewRows({\n      updates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => {\n      var _idRowsLookup$id;\n\n      return [id, (_idRowsLookup$id = idRowsLookup[id]) != null ? _idRowsLookup$id : {}];\n    }));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI: Only group nodes can be expanded or collapsed');\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowTreeSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n\n        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n\n    if (!node) {\n      throw new Error(`MUI: No row with id #${rowId} found`);\n    }\n\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(`MUI: The row reordering do not support reordering of grouped rows yet`);\n    }\n\n    if (node.type !== 'leaf') {\n      throw new Error(`MUI: The row reordering do not support reordering of footer or grouping rows`);\n    }\n\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n\n      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [replacedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n      delete dataRowIdToModelLookup[replacedRowId];\n      delete dataRowIdToIdLookup[replacedRowId];\n      delete tree[replacedRowId];\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n    }\n\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    }); // Removes potential remaining skeleton rows from the dataRowIds.\n\n    const dataRowIds = rootGroupChildren.filter(childId => tree[childId].type === 'leaf');\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"sources":["C:/Users/thang/Downloads/Code structure/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowGroupingNameSelector","gridRowTreeDepthsSelector","gridDataRowIdsSelector","gridRowsDataRowIdToIdLookupSelector","gridRowMaximumTreeDepthSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","isAutoGeneratedRow","GRID_ROOT_GROUP_ID","updateCacheWithNewRows","getTopLevelRowCount","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","caches","rows","getRowId","loading","rowCount","rowCountProp","loadingProp","previousTree","previousTreeDepths","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","id","model","node","getRowNode","lookup","useMemo","reduce","acc","index","throttledRowsChange","cache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","length","prevCache","rowsBeforePartialUpdates","updateRows","updates","signature","DataGrid","Error","join","previousCache","getRowModels","dataRows","idRowsLookup","Map","map","_idRowsLookup$id","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","type","newNode","childrenExpanded","tree","_ref","getRowGroupChildren","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","push","filteredRowsLookup","filter","childId","setRowIndex","rowId","targetIndex","parent","group","instanceId","allRows","oldIndex","row","updatedRows","splice","replaceRows","firstRowToRender","newRows","treeDepth","dataRowIdToModelLookup","dataRowIdToIdLookup","rootGroup","rootGroupChildren","i","rowModel","replacedRowId","rowTreeNodeConfig","groupingKey","dataRowIds","rowApi","unstable_replaceRows","rowProApi","groupRows","info","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","getActiveStrategy","applyHydrateRowsProcessor","response","unstable_applyPipeProcessors","treeDepths","totalTopLevelRowCount","useEffect","isFirstRender","areNewRowsAlreadyInState","isNewLoadingAlreadyInState","loadingPropBeforePartialUpdates","isNewRowCountAlreadyInState","rowCountPropBeforePartialUpdates","totalRowCount","Math","max"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutoGeneratedRow, GRID_ROOT_GROUP_ID, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {\n      // Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n    if (model) {\n      return model;\n    }\n    const node = apiRef.current.getRowNode(id);\n    if (node && isAutoGeneratedRow(node)) {\n      // TODO rows v6: Is it the best approach ?\n      return {};\n    }\n    return null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(({\n    cache,\n    throttle\n  }) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n    apiRef.current.caches.rows = cache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n\n  /**\n   * API METHODS\n   */\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    const cache = updateCacheWithNewRows({\n      updates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => {\n      var _idRowsLookup$id;\n      return [id, (_idRowsLookup$id = idRowsLookup[id]) != null ? _idRowsLookup$id : {}];\n    }));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI: Only group nodes can be expanded or collapsed');\n    }\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _ref;\n    return (_ref = gridRowTreeSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n    if (applySorting) {\n      const groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n    if (!node) {\n      throw new Error(`MUI: No row with id #${rowId} found`);\n    }\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(`MUI: The row reordering do not support reordering of grouped rows yet`);\n    }\n    if (node.type !== 'leaf') {\n      throw new Error(`MUI: The row reordering do not support reordering of footer or grouping rows`);\n    }\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [replacedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n      delete dataRowIdToModelLookup[replacedRowId];\n      delete dataRowIdToIdLookup[replacedRowId];\n      delete tree[replacedRowId];\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n    }\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    });\n\n    // Removes potential remaining skeleton rows from the dataRowIds.\n    const dataRowIds = rootGroupChildren.filter(childId => tree[childId].type === 'leaf');\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n\n  /**\n   * EVENTS\n   */\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n\n  /**\n   * APPLIERS\n   */\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n\n  /**\n   * EFFECTS\n   */\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;\n\n    // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      return;\n    }\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"]},"metadata":{},"sourceType":"module"}