{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"item\", \"applyValue\", \"type\", \"apiRef\", \"focusElementRef\", \"color\", \"error\", \"helperText\", \"size\", \"variant\", \"getOptionLabel\", \"getOptionValue\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport Autocomplete, { createFilterOptions } from '@mui/material/Autocomplete';\nimport Chip from '@mui/material/Chip';\nimport { unstable_useId as useId } from '@mui/utils';\nimport { isSingleSelectColDef } from './filterPanelUtils';\nimport { useGridRootProps } from '../../../hooks/utils/useGridRootProps';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst filter = createFilterOptions();\n\nfunction GridFilterInputMultipleSingleSelect(props) {\n  var _resolvedColumn, _resolvedColumn2;\n\n  const {\n    item,\n    applyValue,\n    apiRef,\n    focusElementRef,\n    color,\n    error,\n    helperText,\n    size,\n    variant = 'standard',\n    getOptionLabel: getOptionLabelProp,\n    getOptionValue: getOptionValueProp\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, _excluded);\n\n  const TextFieldProps = {\n    color,\n    error,\n    helperText,\n    size,\n    variant\n  };\n  const id = useId();\n  const rootProps = useGridRootProps();\n  let resolvedColumn = null;\n\n  if (item.field) {\n    const column = apiRef.current.getColumn(item.field);\n\n    if (isSingleSelectColDef(column)) {\n      resolvedColumn = column;\n    }\n  }\n\n  const getOptionValue = getOptionValueProp || ((_resolvedColumn = resolvedColumn) == null ? void 0 : _resolvedColumn.getOptionValue);\n  const getOptionLabel = getOptionLabelProp || ((_resolvedColumn2 = resolvedColumn) == null ? void 0 : _resolvedColumn2.getOptionLabel);\n  const isOptionEqualToValue = React.useCallback((option, value) => getOptionValue(option) === getOptionValue(value), [getOptionValue]);\n  const resolvedValueOptions = React.useMemo(() => {\n    var _resolvedColumn3;\n\n    if (!((_resolvedColumn3 = resolvedColumn) != null && _resolvedColumn3.valueOptions)) {\n      return [];\n    }\n\n    if (typeof resolvedColumn.valueOptions === 'function') {\n      return resolvedColumn.valueOptions({\n        field: resolvedColumn.field\n      });\n    }\n\n    return resolvedColumn.valueOptions;\n  }, [resolvedColumn]);\n  const resolvedFormattedValueOptions = React.useMemo(() => {\n    return resolvedValueOptions == null ? void 0 : resolvedValueOptions.map(getOptionValue);\n  }, [resolvedValueOptions, getOptionValue]); // The value is computed from the item.value and used directly\n  // If it was done by a useEffect/useState, the Autocomplete could receive incoherent value and options\n\n  const filteredValues = React.useMemo(() => {\n    if (!Array.isArray(item.value)) {\n      return [];\n    }\n\n    if (resolvedValueOptions !== undefined) {\n      const itemValueIndexes = item.value.map(element => {\n        // Gets the index matching between values and valueOptions\n        return resolvedFormattedValueOptions == null ? void 0 : resolvedFormattedValueOptions.findIndex(formattedOption => formattedOption === element);\n      });\n      return itemValueIndexes.filter(index => index >= 0).map(index => resolvedValueOptions[index]);\n    }\n\n    return item.value;\n  }, [item.value, resolvedValueOptions, resolvedFormattedValueOptions]);\n  React.useEffect(() => {\n    if (!Array.isArray(item.value) || filteredValues.length !== item.value.length) {\n      // Updates the state if the filter value has been cleaned by the component\n      applyValue(_extends({}, item, {\n        value: filteredValues.map(getOptionValue)\n      }));\n    }\n  }, [item, filteredValues, applyValue, getOptionValue]);\n  const handleChange = React.useCallback((event, value) => {\n    applyValue(_extends({}, item, {\n      value: value.map(getOptionValue)\n    }));\n  }, [applyValue, item, getOptionValue]);\n  return /*#__PURE__*/_jsx(Autocomplete, _extends({\n    multiple: true,\n    options: resolvedValueOptions,\n    isOptionEqualToValue: isOptionEqualToValue,\n    filterOptions: filter,\n    id: id,\n    value: filteredValues,\n    onChange: handleChange,\n    getOptionLabel: getOptionLabel,\n    renderTags: (value, getTagProps) => value.map((option, index) => /*#__PURE__*/_jsx(Chip, _extends({\n      variant: \"outlined\",\n      size: \"small\",\n      label: getOptionLabel(option)\n    }, getTagProps({\n      index\n    })))),\n    renderInput: params => {\n      var _rootProps$slotProps;\n\n      return /*#__PURE__*/_jsx(rootProps.slots.baseTextField, _extends({}, params, {\n        label: apiRef.current.getLocaleText('filterPanelInputLabel'),\n        placeholder: apiRef.current.getLocaleText('filterPanelInputPlaceholder'),\n        InputLabelProps: _extends({}, params.InputLabelProps, {\n          shrink: true\n        }),\n        inputRef: focusElementRef,\n        type: \"singleSelect\"\n      }, TextFieldProps, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));\n    }\n  }, other));\n}\n\nprocess.env.NODE_ENV !== \"production\" ? GridFilterInputMultipleSingleSelect.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  apiRef: PropTypes.shape({\n    current: PropTypes.object.isRequired\n  }).isRequired,\n  applyValue: PropTypes.func.isRequired,\n  focusElementRef: PropTypes\n  /* @typescript-to-proptypes-ignore */\n  .oneOfType([PropTypes.func, PropTypes.object]),\n\n  /**\n   * Used to determine the label displayed for a given value option.\n   * @param {ValueOptions} value The current value option.\n   * @returns {string} The text to be displayed.\n   */\n  getOptionLabel: PropTypes.func,\n\n  /**\n   * Used to determine the value used for a value option.\n   * @param {ValueOptions} value The current value option.\n   * @returns {string} The value to be used.\n   */\n  getOptionValue: PropTypes.func,\n  item: PropTypes.shape({\n    field: PropTypes.string.isRequired,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    operator: PropTypes.string.isRequired,\n    value: PropTypes.any\n  }).isRequired,\n  type: PropTypes.oneOf(['singleSelect'])\n} : void 0;\nexport { GridFilterInputMultipleSingleSelect };","map":{"version":3,"sources":["C:/Users/thang/Downloads/Code structure/node_modules/@mui/x-data-grid/components/panel/filterPanel/GridFilterInputMultipleSingleSelect.js"],"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","PropTypes","Autocomplete","createFilterOptions","Chip","unstable_useId","useId","isSingleSelectColDef","useGridRootProps","jsx","_jsx","filter","GridFilterInputMultipleSingleSelect","props","_resolvedColumn","_resolvedColumn2","item","applyValue","apiRef","focusElementRef","color","error","helperText","size","variant","getOptionLabel","getOptionLabelProp","getOptionValue","getOptionValueProp","other","TextFieldProps","id","rootProps","resolvedColumn","field","column","current","getColumn","isOptionEqualToValue","useCallback","option","value","resolvedValueOptions","useMemo","_resolvedColumn3","valueOptions","resolvedFormattedValueOptions","map","filteredValues","Array","isArray","undefined","itemValueIndexes","element","findIndex","formattedOption","index","useEffect","length","handleChange","event","multiple","options","filterOptions","onChange","renderTags","getTagProps","label","renderInput","params","_rootProps$slotProps","slots","baseTextField","getLocaleText","placeholder","InputLabelProps","shrink","inputRef","type","slotProps","process","env","NODE_ENV","propTypes","shape","object","isRequired","func","oneOfType","string","number","operator","any","oneOf"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"item\", \"applyValue\", \"type\", \"apiRef\", \"focusElementRef\", \"color\", \"error\", \"helperText\", \"size\", \"variant\", \"getOptionLabel\", \"getOptionValue\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport Autocomplete, { createFilterOptions } from '@mui/material/Autocomplete';\nimport Chip from '@mui/material/Chip';\nimport { unstable_useId as useId } from '@mui/utils';\nimport { isSingleSelectColDef } from './filterPanelUtils';\nimport { useGridRootProps } from '../../../hooks/utils/useGridRootProps';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst filter = createFilterOptions();\nfunction GridFilterInputMultipleSingleSelect(props) {\n  var _resolvedColumn, _resolvedColumn2;\n  const {\n      item,\n      applyValue,\n      apiRef,\n      focusElementRef,\n      color,\n      error,\n      helperText,\n      size,\n      variant = 'standard',\n      getOptionLabel: getOptionLabelProp,\n      getOptionValue: getOptionValueProp\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const TextFieldProps = {\n    color,\n    error,\n    helperText,\n    size,\n    variant\n  };\n  const id = useId();\n  const rootProps = useGridRootProps();\n  let resolvedColumn = null;\n  if (item.field) {\n    const column = apiRef.current.getColumn(item.field);\n    if (isSingleSelectColDef(column)) {\n      resolvedColumn = column;\n    }\n  }\n  const getOptionValue = getOptionValueProp || ((_resolvedColumn = resolvedColumn) == null ? void 0 : _resolvedColumn.getOptionValue);\n  const getOptionLabel = getOptionLabelProp || ((_resolvedColumn2 = resolvedColumn) == null ? void 0 : _resolvedColumn2.getOptionLabel);\n  const isOptionEqualToValue = React.useCallback((option, value) => getOptionValue(option) === getOptionValue(value), [getOptionValue]);\n  const resolvedValueOptions = React.useMemo(() => {\n    var _resolvedColumn3;\n    if (!((_resolvedColumn3 = resolvedColumn) != null && _resolvedColumn3.valueOptions)) {\n      return [];\n    }\n    if (typeof resolvedColumn.valueOptions === 'function') {\n      return resolvedColumn.valueOptions({\n        field: resolvedColumn.field\n      });\n    }\n    return resolvedColumn.valueOptions;\n  }, [resolvedColumn]);\n  const resolvedFormattedValueOptions = React.useMemo(() => {\n    return resolvedValueOptions == null ? void 0 : resolvedValueOptions.map(getOptionValue);\n  }, [resolvedValueOptions, getOptionValue]);\n\n  // The value is computed from the item.value and used directly\n  // If it was done by a useEffect/useState, the Autocomplete could receive incoherent value and options\n  const filteredValues = React.useMemo(() => {\n    if (!Array.isArray(item.value)) {\n      return [];\n    }\n    if (resolvedValueOptions !== undefined) {\n      const itemValueIndexes = item.value.map(element => {\n        // Gets the index matching between values and valueOptions\n        return resolvedFormattedValueOptions == null ? void 0 : resolvedFormattedValueOptions.findIndex(formattedOption => formattedOption === element);\n      });\n      return itemValueIndexes.filter(index => index >= 0).map(index => resolvedValueOptions[index]);\n    }\n    return item.value;\n  }, [item.value, resolvedValueOptions, resolvedFormattedValueOptions]);\n  React.useEffect(() => {\n    if (!Array.isArray(item.value) || filteredValues.length !== item.value.length) {\n      // Updates the state if the filter value has been cleaned by the component\n      applyValue(_extends({}, item, {\n        value: filteredValues.map(getOptionValue)\n      }));\n    }\n  }, [item, filteredValues, applyValue, getOptionValue]);\n  const handleChange = React.useCallback((event, value) => {\n    applyValue(_extends({}, item, {\n      value: value.map(getOptionValue)\n    }));\n  }, [applyValue, item, getOptionValue]);\n  return /*#__PURE__*/_jsx(Autocomplete, _extends({\n    multiple: true,\n    options: resolvedValueOptions,\n    isOptionEqualToValue: isOptionEqualToValue,\n    filterOptions: filter,\n    id: id,\n    value: filteredValues,\n    onChange: handleChange,\n    getOptionLabel: getOptionLabel,\n    renderTags: (value, getTagProps) => value.map((option, index) => /*#__PURE__*/_jsx(Chip, _extends({\n      variant: \"outlined\",\n      size: \"small\",\n      label: getOptionLabel(option)\n    }, getTagProps({\n      index\n    })))),\n    renderInput: params => {\n      var _rootProps$slotProps;\n      return /*#__PURE__*/_jsx(rootProps.slots.baseTextField, _extends({}, params, {\n        label: apiRef.current.getLocaleText('filterPanelInputLabel'),\n        placeholder: apiRef.current.getLocaleText('filterPanelInputPlaceholder'),\n        InputLabelProps: _extends({}, params.InputLabelProps, {\n          shrink: true\n        }),\n        inputRef: focusElementRef,\n        type: \"singleSelect\"\n      }, TextFieldProps, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));\n    }\n  }, other));\n}\nprocess.env.NODE_ENV !== \"production\" ? GridFilterInputMultipleSingleSelect.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  apiRef: PropTypes.shape({\n    current: PropTypes.object.isRequired\n  }).isRequired,\n  applyValue: PropTypes.func.isRequired,\n  focusElementRef: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.func, PropTypes.object]),\n  /**\n   * Used to determine the label displayed for a given value option.\n   * @param {ValueOptions} value The current value option.\n   * @returns {string} The text to be displayed.\n   */\n  getOptionLabel: PropTypes.func,\n  /**\n   * Used to determine the value used for a value option.\n   * @param {ValueOptions} value The current value option.\n   * @returns {string} The value to be used.\n   */\n  getOptionValue: PropTypes.func,\n  item: PropTypes.shape({\n    field: PropTypes.string.isRequired,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    operator: PropTypes.string.isRequired,\n    value: PropTypes.any\n  }).isRequired,\n  type: PropTypes.oneOf(['singleSelect'])\n} : void 0;\nexport { GridFilterInputMultipleSingleSelect };"]},"metadata":{},"sourceType":"module"}