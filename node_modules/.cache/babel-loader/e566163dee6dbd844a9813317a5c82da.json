{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector } from '../columns';\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\n\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\n\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n\n  const column = apiRef.current.getColumn(filterItem.field);\n\n  if (!column) {\n    return null;\n  }\n\n  let parsedValue;\n\n  if (column.valueParser) {\n    var _filterItem$value;\n\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n\n  const filterOperators = column.filterOperators;\n\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n  }\n\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n\n  if (!filterOperator) {\n    throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n\n  const fn = rowId => {\n    const cellParams = apiRef.current.getCellParams(rowId, newFilterItem.field);\n    return applyFilterOnRow(cellParams);\n  };\n\n  return {\n    fn,\n    item: newFilterItem\n  };\n};\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\n\nexport const buildAggregatedFilterItemsApplier = (filterModel, apiRef) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  return (rowId, shouldApplyFilter) => {\n    const resultPerItemId = {};\n    const filteredAppliers = shouldApplyFilter ? appliers.filter(applier => shouldApplyFilter(applier.item.field)) : appliers;\n    filteredAppliers.forEach(applier => {\n      resultPerItemId[applier.item.id] = applier.fn(rowId);\n    });\n    return resultPerItemId;\n  };\n};\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} values The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport const buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const {\n    quickFilterValues = []\n  } = filterModel;\n\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n\n  const columnsFields = gridColumnFieldsSelector(apiRef);\n  const appliersPerField = {};\n  columnsFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n\n    if (!getApplyQuickFilterFn) {\n      return;\n    }\n\n    appliersPerField[field] = quickFilterValues.map(value => getApplyQuickFilterFn(value, column, apiRef));\n  }); // If some value does not have an applier we ignore them\n\n  const sanitizedQuickFilterValues = quickFilterValues.filter((value, index) => Object.keys(appliersPerField).some(field => appliersPerField[field][index] != null));\n\n  if (sanitizedQuickFilterValues.length === 0) {\n    return null;\n  }\n\n  return (rowId, shouldApplyFilter) => {\n    const usedCellParams = {};\n    const fieldsToFilter = [];\n    Object.keys(appliersPerField).forEach(field => {\n      if (!shouldApplyFilter || shouldApplyFilter(field)) {\n        usedCellParams[field] = apiRef.current.getCellParams(rowId, field);\n        fieldsToFilter.push(field);\n      }\n    });\n    const quickFilterValueResult = {};\n    sanitizedQuickFilterValues.forEach((value, index) => {\n      const isPassing = fieldsToFilter.some(field => {\n        var _appliersPerField$fie, _appliersPerField$fie2;\n\n        if (appliersPerField[field][index] == null) {\n          return false;\n        }\n\n        return (_appliersPerField$fie = (_appliersPerField$fie2 = appliersPerField[field])[index]) == null ? void 0 : _appliersPerField$fie.call(_appliersPerField$fie2, usedCellParams[field]);\n      });\n      quickFilterValueResult[value] = isPassing;\n    });\n    return quickFilterValueResult;\n  };\n};\nexport const buildAggregatedFilterApplier = (filterModel, apiRef) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return (rowId, shouldApplyFilter) => ({\n    passingFilterItems: isRowMatchingFilterItems && isRowMatchingFilterItems(rowId, shouldApplyFilter),\n    passingQuickFilterValues: isRowMatchingQuickFilter && isRowMatchingQuickFilter(rowId, shouldApplyFilter)\n  });\n};\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef) => {\n  var _filterModel$quickFil, _filterModel$logicOpe;\n\n  const cleanedFilterItems = filterModel.items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  const cleanedAllFilterItemResults = allFilterItemResults.filter(result => result != null);\n  const cleanedAllQuickFilterResults = allQuickFilterResults.filter(result => result != null); // Defaultize operators\n\n  const quickFilterLogicOperator = (_filterModel$quickFil = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil : getDefaultGridFilterModel().quickFilterLogicOperator;\n  const logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator; // get result for filter items model\n\n  if (cleanedAllFilterItemResults.length > 0) {\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedAllFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  } // get result for quick filter model\n\n\n  if (cleanedAllQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedAllQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};","map":{"version":3,"sources":["C:/Users/thang/Downloads/Code structure/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"names":["_extends","GridLogicOperator","getDefaultGridFilterModel","buildWarning","gridColumnFieldsSelector","gridColumnLookupSelector","cleanFilterItem","item","apiRef","cleanItem","id","Math","round","random","operator","column","field","filterOperators","value","filterModelDisableMultiColumnsFilteringWarning","filterModelMissingItemIdWarning","filterModelMissingItemOperatorWarning","sanitizeFilterModel","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","hasItemsWithoutIds","some","hasItemWithoutOperator","map","mergeStateWithFilterModel","filterModel","filteringState","getFilterCallbackFromItem","filterItem","current","getColumn","parsedValue","valueParser","_filterItem$value","parser","Array","isArray","x","newFilterItem","Error","filterOperator","find","applyFilterOnRow","getApplyFilterFn","fn","rowId","cellParams","getCellParams","buildAggregatedFilterItemsApplier","appliers","filter","callback","shouldApplyFilter","resultPerItemId","filteredAppliers","applier","forEach","buildAggregatedQuickFilterApplier","quickFilterValues","columnsFields","appliersPerField","getApplyQuickFilterFn","sanitizedQuickFilterValues","index","Object","keys","usedCellParams","fieldsToFilter","push","quickFilterValueResult","isPassing","_appliersPerField$fie","_appliersPerField$fie2","call","buildAggregatedFilterApplier","isRowMatchingFilterItems","isRowMatchingQuickFilter","passingFilterItems","passingQuickFilterValues","passFilterLogic","allFilterItemResults","allQuickFilterResults","_filterModel$quickFil","_filterModel$logicOpe","cleanedFilterItems","cleanedAllFilterItemResults","result","cleanedAllQuickFilterResults","quickFilterLogicOperator","logicOperator","filterItemPredicate","filterItemResult","And","passesAllFilters","every","passesSomeFilters","quickFilterValuePredicate","passesAllQuickFilterValues","passesSomeQuickFilterValues"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector } from '../columns';\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    var _filterItem$value;\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  const fn = rowId => {\n    const cellParams = apiRef.current.getCellParams(rowId, newFilterItem.field);\n    return applyFilterOnRow(cellParams);\n  };\n  return {\n    fn,\n    item: newFilterItem\n  };\n};\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport const buildAggregatedFilterItemsApplier = (filterModel, apiRef) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n  return (rowId, shouldApplyFilter) => {\n    const resultPerItemId = {};\n    const filteredAppliers = shouldApplyFilter ? appliers.filter(applier => shouldApplyFilter(applier.item.field)) : appliers;\n    filteredAppliers.forEach(applier => {\n      resultPerItemId[applier.item.id] = applier.fn(rowId);\n    });\n    return resultPerItemId;\n  };\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} values The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport const buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const {\n    quickFilterValues = []\n  } = filterModel;\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const columnsFields = gridColumnFieldsSelector(apiRef);\n  const appliersPerField = {};\n  columnsFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n    if (!getApplyQuickFilterFn) {\n      return;\n    }\n    appliersPerField[field] = quickFilterValues.map(value => getApplyQuickFilterFn(value, column, apiRef));\n  });\n\n  // If some value does not have an applier we ignore them\n  const sanitizedQuickFilterValues = quickFilterValues.filter((value, index) => Object.keys(appliersPerField).some(field => appliersPerField[field][index] != null));\n  if (sanitizedQuickFilterValues.length === 0) {\n    return null;\n  }\n  return (rowId, shouldApplyFilter) => {\n    const usedCellParams = {};\n    const fieldsToFilter = [];\n    Object.keys(appliersPerField).forEach(field => {\n      if (!shouldApplyFilter || shouldApplyFilter(field)) {\n        usedCellParams[field] = apiRef.current.getCellParams(rowId, field);\n        fieldsToFilter.push(field);\n      }\n    });\n    const quickFilterValueResult = {};\n    sanitizedQuickFilterValues.forEach((value, index) => {\n      const isPassing = fieldsToFilter.some(field => {\n        var _appliersPerField$fie, _appliersPerField$fie2;\n        if (appliersPerField[field][index] == null) {\n          return false;\n        }\n        return (_appliersPerField$fie = (_appliersPerField$fie2 = appliersPerField[field])[index]) == null ? void 0 : _appliersPerField$fie.call(_appliersPerField$fie2, usedCellParams[field]);\n      });\n      quickFilterValueResult[value] = isPassing;\n    });\n    return quickFilterValueResult;\n  };\n};\nexport const buildAggregatedFilterApplier = (filterModel, apiRef) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return (rowId, shouldApplyFilter) => ({\n    passingFilterItems: isRowMatchingFilterItems && isRowMatchingFilterItems(rowId, shouldApplyFilter),\n    passingQuickFilterValues: isRowMatchingQuickFilter && isRowMatchingQuickFilter(rowId, shouldApplyFilter)\n  });\n};\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef) => {\n  var _filterModel$quickFil, _filterModel$logicOpe;\n  const cleanedFilterItems = filterModel.items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  const cleanedAllFilterItemResults = allFilterItemResults.filter(result => result != null);\n  const cleanedAllQuickFilterResults = allQuickFilterResults.filter(result => result != null);\n\n  // Defaultize operators\n  const quickFilterLogicOperator = (_filterModel$quickFil = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil : getDefaultGridFilterModel().quickFilterLogicOperator;\n  const logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;\n\n  // get result for filter items model\n  if (cleanedAllFilterItemResults.length > 0) {\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedAllFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedAllQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedAllQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};"]},"metadata":{},"sourceType":"module"}