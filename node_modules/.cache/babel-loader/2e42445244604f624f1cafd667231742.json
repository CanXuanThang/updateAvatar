{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.orderedFields.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n\n  return newColumnsState;\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnTypes,\n  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n\n  let columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n\n    if (existingState == null) {\n      let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n\n      if (newColumn.type && columnTypes[newColumn.type]) {\n        colDef = columnTypes[newColumn.type];\n      }\n\n      existingState = _extends({}, colDef, {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender({\n  firstColumnIndex,\n  minColumnIndex,\n  columnBuffer,\n  firstRowToRender,\n  lastRowToRender,\n  apiRef,\n  visibleRows\n}) {\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, headerHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);\n}","map":{"version":3,"sources":["C:/Users/thang/Downloads/Code structure/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","gridColumnsStateSelector","gridColumnVisibilityModelSelector","clamp","gridDensityFactorSelector","gridColumnGroupsHeaderMaxDepthSelector","COLUMNS_DIMENSION_PROPERTIES","computeFlexColumnsWidth","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","length","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","forEach","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","Object","keys","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","orderedFields","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","applyInitialState","columnsState","initialState","dimensions","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","filter","newColumnLookup","newColDef","hasBeenResized","entries","key","Infinity","newColumnsState","createColumnsState","apiRef","columnsToUpsert","columnTypes","keepOnlyColumnsToUpsert","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","isInsideStateInitializer","current","state","columns","currentState","columnsToKeep","reduce","acc","columnsToUpsertLookup","existingState","colDef","type","undefined","columnsStateWithPreProcessing","unstable_applyPipeProcessors","columnsStateWithPortableColumns","getRootDimensions","call","viewportInnerSize","mergeColumnsState","getFirstNonSpannedColumnToRender","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","getFirstColumnIndexToRender","firstColumnIndex","minColumnIndex","columnBuffer","initialFirstColumnToRender","getTotalHeaderHeight","headerHeight","densityFactor","maxDepth","floor"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n  const newColumnLookup = _extends({}, columnsState.lookup);\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnTypes,\n  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n  let columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n      if (newColumn.type && columnTypes[newColumn.type]) {\n        colDef = columnTypes[newColumn.type];\n      }\n      existingState = _extends({}, colDef, {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender({\n  firstColumnIndex,\n  minColumnIndex,\n  columnBuffer,\n  firstRowToRender,\n  lastRowToRender,\n  apiRef,\n  visibleRows\n}) {\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, headerHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);\n}"]},"metadata":{},"sourceType":"module"}